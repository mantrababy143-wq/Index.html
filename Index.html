<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Will you be my Valentine?</title>
  <style>
    :root{
      --bg:#ffeef2;
      --card:#fff;
      --accent:#ff4d94;
      --muted:#6b6b6b;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{
      display:flex;align-items:center;justify-content:center;
      background:linear-gradient(135deg,var(--bg),#fff7f9);
      padding:20px;
    }
    .card{
      position:relative;
      width:100%;
      max-width:640px;
      height:420px;
      background:var(--card);
      border-radius:18px;
      box-shadow:0 10px 30px rgba(0,0,0,0.12);
      padding:34px;
      box-sizing:border-box;
      text-align:center;
      overflow:hidden;
    }
    h1{
      margin:6px 0 6px;
      font-size:28px;
      color:var(--accent);
    }
    p.lead{
      margin:0 0 18px;
      color:var(--muted);
      font-size:16px;
    }
    .name{
      font-size:22px;
      margin-bottom:2px;
    }
    .buttons{
      position:relative;
      height:170px;
      margin-top:12px;
      touch-action:none; /* so pointer events are consistent on touch */
    }
    button{
      cursor:pointer;
      font-size:18px;
      border:0;
      padding:12px 26px;
      border-radius:999px;
      transition:transform .12s ease, box-shadow .12s ease, left .26s cubic-bezier(.2,.9,.2,1), top .26s cubic-bezier(.2,.9,.2,1);
      box-shadow:0 6px 18px rgba(0,0,0,0.08);
      position:absolute;
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
      will-change: left, top;
      background:transparent;
    }
    button:active{transform:scale(.98)}
    #yes{
      background:linear-gradient(180deg,#ff6fae,#ff3380);
      color:white;
    }
    #no{
      background:#fff;
      border:2px solid #ffb6d6;
      color:var(--accent);
      min-width:120px;
    }
    .hint{font-size:13px;color:#c14b7b;margin-top:6px}
    /* modal */
    .overlay{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.45);z-index:60;
    }
    .modal{
      background:linear-gradient(180deg,#fff6fb,#fff);
      padding:28px;border-radius:14px;max-width:420px;width:92%;
      text-align:center;box-shadow:0 18px 40px rgba(0,0,0,0.18);
    }
    .modal h2{margin:0 0 12px;color:#ff2e86}
    .modal p{margin:0 0 18px;color:#6b6b6b}
    .close{
      background:var(--accent);
      color:#fff;border:0;padding:10px 18px;border-radius:10px;font-weight:600;
      cursor:pointer;
    }
    @media (max-width:480px){
      .card{height:520px;padding:20px}
      h1{font-size:22px}
      #yes, #no{font-size:17px;padding:12px 18px}
    }
  </style>
</head>
<body>
  <div class="card" id="card" role="main" aria-labelledby="q">
    <div style="margin-top:6px">
      <div class="name">Antara üòç</div>
      <h1 id="q">Will you be my Valentine?</h1>
      <p class="lead">Choose one ‚Äî but don't be surprised if No is shy üíï</p>
    </div>

    <div class="buttons" id="buttons" aria-hidden="false">
      <button id="yes" aria-label="Yes">Yes üíñ</button>
      <!-- keep No unfocusable via keyboard so only Yes is selectable by keyboard -->
      <button id="no" aria-label="No" tabindex="-1">No üòÖ</button>
    </div>

    <div class="hint">Tip: try to catch the "No" button üòâ</div>
  </div>

  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" role="document">
      <h2>Thank you ‚ù§Ô∏è</h2>
      <p id="modal-text">i really do love you a lot baby</p>
      <button class="close" id="close">Close</button>
    </div>
  </div>

  <script>
    (function () {
      const container = document.getElementById('buttons');
      const yes = document.getElementById('yes');
      const no = document.getElementById('no');
      const overlay = document.getElementById('overlay');
      const close = document.getElementById('close');

      // Settings: tweak to make "No" more/less jumpy
      const proximityTrigger = 120; // px from No center to trigger a jump
      const minDistanceFromYes = 120; // px center-to-center to avoid landing too close to Yes
      const pad = 8; // padding inside container so button doesn't overlap edges
      const maxAttempts = 60; // tries to find a valid new spot

      // Large max jumps to keep No effectively unselectable
      let jumps = 0;
      const maxJumps = 9999;

      // Initialize positions so they start side-by-side
      function initPositions() {
        const rect = container.getBoundingClientRect();
        const btnW = Math.max(100, Math.min(220, rect.width * 0.22));
        const centerY = Math.round((rect.height - 40) / 2);

        yes.style.width = btnW + 'px';
        no.style.minWidth = btnW + 'px';

        const spacing = 18;
        const yesLeft = Math.max(pad, Math.round(rect.width / 2 - btnW - spacing));
        const noLeft = Math.min(rect.width - btnW - pad, Math.round(rect.width / 2 + spacing));

        yes.style.left = yesLeft + 'px';
        yes.style.top = centerY + 'px';

        no.style.left = noLeft + 'px';
        no.style.top  = centerY + 'px';
      }

      // Clamp helper
      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

      // Generate a random position inside container that:
      // - doesn't overlap edges
      // - keeps a minimum center distance from Yes
      // - ideally is at least proximityTrigger away from pointer (if pointer provided)
      function findGoodPosition(pointerClientX, pointerClientY) {
        const crect = container.getBoundingClientRect();
        const noRect = no.getBoundingClientRect();
        const yesRect = yes.getBoundingClientRect();

        const btnW = noRect.width;
        const btnH = noRect.height;
        const yesCenterX = yesRect.left + yesRect.width / 2;
        const yesCenterY = yesRect.top + yesRect.height / 2;

        // try multiple times to find a good spot
        for (let i = 0; i < maxAttempts; i++) {
          // random x, y within container with padding
          const x = pad + Math.random() * (crect.width - btnW - pad * 2);
          const y = pad + Math.random() * (crect.height - btnH - pad * 2);

          const absCenterX = crect.left + x + btnW / 2;
          const absCenterY = crect.top + y + btnH / 2;

          const distFromYes = Math.hypot(absCenterX - yesCenterX, absCenterY - yesCenterY);
          if (distFromYes < minDistanceFromYes) continue;

          if (pointerClientX != null && pointerClientY != null) {
            const distFromPointer = Math.hypot(absCenterX - pointerClientX, absCenterY - pointerClientY);
            if (distFromPointer < proximityTrigger * 0.9) continue; // keep some buffer from pointer
          }

          return { left: Math.round(x), top: Math.round(y) };
        }

        // fallback strategies if we couldn't find a perfect spot:
        // try left edge, right edge, top, bottom (but keep min distance from Yes)
        const candidates = [
          { left: pad, top: pad },
          { left: crect.width - btnW - pad, top: pad },
          { left: pad, top: crect.height - btnH - pad },
          { left: crect.width - btnW - pad, top: crect.height - btnH - pad },
          { left: Math.round(crect.width * 0.1), top: Math.round(crect.height / 2) },
          { left: Math.round(crect.width * 0.9) - btnW, top: Math.round(crect.height / 2) }
        ];

        for (const c of candidates) {
          const absCenterX = crect.left + c.left + btnW / 2;
          const absCenterY = crect.top + c.top + btnH / 2;
          const distFromYes = Math.hypot(absCenterX - yesCenterX, absCenterY - yesCenterY);
          if (distFromYes >= minDistanceFromYes) return c;
        }

        // last resort, just clamp somewhere
        return { left: clamp(pad, pad, crect.width - btnW - pad), top: clamp(pad, pad, crect.height - btnH - pad) };
      }

      // Move No to a new place (run away)
      function moveNo(pointerClientX = null, pointerClientY = null) {
        if (jumps >= maxJumps) return;
        jumps++;

        const crect = container.getBoundingClientRect();
        const noRect = no.getBoundingClientRect();
        const btnW = noRect.width;
        const btnH = noRect.height;

        const pos = findGoodPosition(pointerClientX, pointerClientY);

        // apply
        no.style.left = clamp(pos.left, pad, crect.width - btnW - pad) + 'px';
        no.style.top  = clamp(pos.top,  pad, crect.height - btnH - pad) + 'px';
      }

      // Event handlers that trigger the runaway behaviour
      function handlePointerMove(e) {
        // ignore if No somehow has keyboard focus (not focusable due to tabindex="-1" but just in case)
        if (document.activeElement === no) return;

        const btnRect = no.getBoundingClientRect();
        const centerX = btnRect.left + btnRect.width / 2;
        const centerY = btnRect.top + btnRect.height / 2;

        const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
        const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;

        const dist = Math.hypot(clientX - centerX, clientY - centerY);

        if (dist < proximityTrigger && jumps < maxJumps) {
          // run away from the pointer
          moveNo(clientX, clientY);
        }
      }

      function handleDirectTry(ev) {
        // When the user tries to directly interact (hover, down, click) with No,
        // prevent the click and make it jump to a new location.
        // For touchstart we must call preventDefault to avoid the subsequent click/tap.
        try { ev.preventDefault(); } catch (e) {}
        try { ev.stopPropagation(); } catch (e) {}
        const clientX = (ev.touches && ev.touches[0]) ? ev.touches[0].clientX : (ev.clientX || null);
        const clientY = (ev.touches && ev.touches[0]) ? ev.touches[0].clientY : (ev.clientY || null);
        moveNo(clientX, clientY);
      }

      // Make No unreacheable by keyboard; if it ever gets focus blur it
      no.addEventListener('focus', () => no.blur());

      // Pointer events for approach detection across the whole container
      container.addEventListener('pointermove', handlePointerMove, { passive: true });
      container.addEventListener('touchstart', handlePointerMove, { passive: true });

      // Direct interactions on the No button cause a jump
      no.addEventListener('pointerenter', handleDirectTry);
      no.addEventListener('pointerdown', handleDirectTry);
      no.addEventListener('click', handleDirectTry);
      no.addEventListener('touchstart', function (e) { e.preventDefault && e.preventDefault(); handleDirectTry(e); }, { passive: false });

      // Reinitialize positions on load/resize (keeps layout consistent)
      window.addEventListener('load', initPositions);
      window.addEventListener('resize', initPositions);

      // Yes click -> show modal with the exact requested message
      yes.addEventListener('click', function () {
        overlay.style.display = 'flex';
        overlay.setAttribute('aria-hidden', 'false');
        document.getElementById('modal-text').textContent = 'i really do love you a lot baby';
        // small feedback animation
        yes.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.06)' }, { transform: 'scale(1)' }], { duration: 420, iterations: 1, easing: 'ease-out' });
      });

      close.addEventListener('click', function () {
        overlay.style.display = 'none';
        overlay.setAttribute('aria-hidden', 'true');
      });

      // If tabbing around somehow focuses No, move the focus back to Yes
      document.addEventListener('keydown', function (e) {
        if (e.key === 'Tab' && document.activeElement === no) {
          e.preventDefault();
          yes.focus();
        }
      });
    })();
  </script>
</body>
</html>